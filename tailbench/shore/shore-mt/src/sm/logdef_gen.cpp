/* DO NOT MODIFY --- generated by ../../tools/logdef.pl from logdef.dat 
                     on Wed Sep  1 18:45:13 2021

<std-header orig-src='shore' genfile='true'>

SHORE -- Scalable Heterogeneous Object REpository

Copyright (c) 1994-99 Computer Sciences Department, University of
                      Wisconsin -- Madison
All Rights Reserved.

Permission to use, copy, modify and distribute this software and its
documentation is hereby granted, provided that both the copyright
notice and this permission notice appear in all copies of the
software, derivative works or modified versions, and any portions
thereof, and that both notices appear in supporting documentation.

THE AUTHORS AND THE COMPUTER SCIENCES DEPARTMENT OF THE UNIVERSITY
OF WISCONSIN - MADISON ALLOW FREE USE OF THIS SOFTWARE IN ITS
"AS IS" CONDITION, AND THEY DISCLAIM ANY LIABILITY OF ANY KIND
FOR ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.

This software was developed with support by the Advanced Research
Project Agency, ARPA order number 018 (formerly 8230), monitored by
the U.S. Army Research Laboratory under contract DAAB07-91-C-Q518.
Further funding for this work was provided by DARPA through
Rome Research Laboratory Contract No. F30602-97-2-0247.

*/

#include "w_defines.h"

/*  -- do not edit anything above this line --   </std-header>*/


    class comment_log : public logrec_t {
	void fill(const lpid_t* p, uint2_t tag, int l) {
	  _cat = 0|t_redo|t_undo|t_logical, _type = t_comment;
	  logrec_t::fill(p, tag, l);
	}
      public:
	comment_log (const char* msg);
	comment_log (logrec_t*)   {};
	
	void redo(page_p*);
	void undo(page_p*);
    };

    class compensate_log : public logrec_t {
	void fill(const lpid_t* p, uint2_t tag, int l) {
	  _cat = 0|t_logical, _type = t_compensate;
	  logrec_t::fill(p, tag, l);
	}
      public:
	compensate_log (lsn_t rec_lsn);
	compensate_log (logrec_t*)   {};
	
	
	
    };

    class skip_log : public logrec_t {
	void fill(const lpid_t* p, uint2_t tag, int l) {
	  _cat = t_status, _type = t_skip;
	  logrec_t::fill(p, tag, l);
	}
      public:
	skip_log ();
	skip_log (logrec_t*)   {};
	
	
	
    };

    class chkpt_begin_log : public logrec_t {
	void fill(const lpid_t* p, uint2_t tag, int l) {
	  _cat = t_status, _type = t_chkpt_begin;
	  logrec_t::fill(p, tag, l);
	}
      public:
	chkpt_begin_log (const lsn_t &lastMountLSN);
	chkpt_begin_log (logrec_t*)   {};
	
	
	
    };

    class chkpt_bf_tab_log : public logrec_t {
	void fill(const lpid_t* p, uint2_t tag, int l) {
	  _cat = t_status, _type = t_chkpt_bf_tab;
	  logrec_t::fill(p, tag, l);
	}
      public:
	chkpt_bf_tab_log (int cnt, const lpid_t* pid, const lsn_t* rec_lsn);
	chkpt_bf_tab_log (logrec_t*)   {};
	
	
	
    };

    class chkpt_xct_tab_log : public logrec_t {
	void fill(const lpid_t* p, uint2_t tag, int l) {
	  _cat = t_status, _type = t_chkpt_xct_tab;
	  logrec_t::fill(p, tag, l);
	}
      public:
	chkpt_xct_tab_log (const tid_t& youngest, int cnt, const tid_t* tid, const smlevel_1::xct_state_t* state, const lsn_t* last_lsn, const lsn_t* undo_nxt);
	chkpt_xct_tab_log (logrec_t*)   {};
	
	
	
    };

    class chkpt_dev_tab_log : public logrec_t {
	void fill(const lpid_t* p, uint2_t tag, int l) {
	  _cat = t_status, _type = t_chkpt_dev_tab;
	  logrec_t::fill(p, tag, l);
	}
      public:
	chkpt_dev_tab_log (int cnt, const char **dev_name, const vid_t* vid);
	chkpt_dev_tab_log (logrec_t*)   {};
	
	
	
    };

    class chkpt_end_log : public logrec_t {
	void fill(const lpid_t* p, uint2_t tag, int l) {
	  _cat = t_status, _type = t_chkpt_end;
	  logrec_t::fill(p, tag, l);
	}
      public:
	chkpt_end_log (const lsn_t& master, const lsn_t& min_rec_lsn);
	chkpt_end_log (logrec_t*)   {};
	
	
	
    };

    class mount_vol_log : public logrec_t {
	void fill(const lpid_t* p, uint2_t tag, int l) {
	  _cat = 0|t_redo, _type = t_mount_vol;
	  logrec_t::fill(p, tag, l);
	}
      public:
	mount_vol_log (const char *dev_name, const vid_t &vid);
	mount_vol_log (logrec_t*)   {};
	
	void redo(page_p*);
	
    };

    class dismount_vol_log : public logrec_t {
	void fill(const lpid_t* p, uint2_t tag, int l) {
	  _cat = 0|t_redo, _type = t_dismount_vol;
	  logrec_t::fill(p, tag, l);
	}
      public:
	dismount_vol_log (const char *dev_name, const vid_t &vid);
	dismount_vol_log (logrec_t*)   {};
	
	void redo(page_p*);
	
    };

    class xct_abort_log : public logrec_t {
	void fill(const lpid_t* p, uint2_t tag, int l) {
	  _cat = t_status, _type = t_xct_abort;
	  logrec_t::fill(p, tag, l);
	}
      public:
	xct_abort_log ();
	xct_abort_log (logrec_t*)   {};
	
	
	
    };

    class xct_freeing_space_log : public logrec_t {
	void fill(const lpid_t* p, uint2_t tag, int l) {
	  _cat = t_status, _type = t_xct_freeing_space;
	  logrec_t::fill(p, tag, l);
	}
      public:
	xct_freeing_space_log ();
	xct_freeing_space_log (logrec_t*)   {};
	
	
	
    };

    class xct_end_log : public logrec_t {
	void fill(const lpid_t* p, uint2_t tag, int l) {
	  _cat = t_status, _type = t_xct_end;
	  logrec_t::fill(p, tag, l);
	}
      public:
	xct_end_log ();
	xct_end_log (logrec_t*)   {};
	
	
	
    };

    class xct_prepare_st_log : public logrec_t {
	void fill(const lpid_t* p, uint2_t tag, int l) {
	  _cat = 0|t_redo, _type = t_xct_prepare_st;
	  logrec_t::fill(p, tag, l);
	}
      public:
	xct_prepare_st_log (const gtid_t* g, const server_handle_t& h);
	xct_prepare_st_log (logrec_t*)   {};
	
	void redo(page_p*);
	
    };

    class xct_prepare_lk_log : public logrec_t {
	void fill(const lpid_t* p, uint2_t tag, int l) {
	  _cat = 0|t_redo, _type = t_xct_prepare_lk;
	  logrec_t::fill(p, tag, l);
	}
      public:
	xct_prepare_lk_log (int num, lock_mode_t mode, lockid_t* lks);
	xct_prepare_lk_log (logrec_t*)   {};
	
	void redo(page_p*);
	
    };

    class xct_prepare_alk_log : public logrec_t {
	void fill(const lpid_t* p, uint2_t tag, int l) {
	  _cat = 0|t_redo, _type = t_xct_prepare_alk;
	  logrec_t::fill(p, tag, l);
	}
      public:
	xct_prepare_alk_log (int num, lockid_t* lks, lock_mode_t* modes);
	xct_prepare_alk_log (logrec_t*)   {};
	
	void redo(page_p*);
	
    };

    class xct_prepare_stores_log : public logrec_t {
	void fill(const lpid_t* p, uint2_t tag, int l) {
	  _cat = 0|t_redo, _type = t_xct_prepare_stores;
	  logrec_t::fill(p, tag, l);
	}
      public:
	xct_prepare_stores_log (int num, const stid_t* stids);
	xct_prepare_stores_log (logrec_t*)   {};
	
	void redo(page_p*);
	
    };

    class xct_prepare_fi_log : public logrec_t {
	void fill(const lpid_t* p, uint2_t tag, int l) {
	  _cat = 0|t_redo, _type = t_xct_prepare_fi;
	  logrec_t::fill(p, tag, l);
	}
      public:
	xct_prepare_fi_log (int numex, int numix, int numsix, int numextent, const lsn_t& first);
	xct_prepare_fi_log (logrec_t*)   {};
	
	void redo(page_p*);
	
    };

    class alloc_file_page_log : public logrec_t {
	void fill(const lpid_t* p, uint2_t tag, int l) {
	  _cat = 0|t_undo|t_logical, _type = t_alloc_file_page;
	  logrec_t::fill(p, tag, l);
	}
      public:
	alloc_file_page_log (const lpid_t& pid);
	alloc_file_page_log (logrec_t*)   {};
	
	
	void undo(page_p*);
    };

    class alloc_pages_in_ext_log : public logrec_t {
	void fill(const lpid_t* p, uint2_t tag, int l) {
	  _cat = 0|t_redo|t_undo|t_logical, _type = t_alloc_pages_in_ext;
	  logrec_t::fill(p, tag, l);
	}
      public:
	alloc_pages_in_ext_log (const page_p& page, snum_t snum, extnum_t idx, const Pmap& pmap);
	alloc_pages_in_ext_log (logrec_t*)   {};
	
	void redo(page_p*);
	void undo(page_p*);
    };

    class free_pages_in_ext_log : public logrec_t {
	void fill(const lpid_t* p, uint2_t tag, int l) {
	  _cat = 0|t_redo|t_undo|t_logical, _type = t_free_pages_in_ext;
	  logrec_t::fill(p, tag, l);
	}
      public:
	free_pages_in_ext_log (const page_p& page, snum_t snum, extnum_t idx, const Pmap& pmap);
	free_pages_in_ext_log (logrec_t*)   {};
	
	void redo(page_p*);
	void undo(page_p*);
    };

    class create_ext_list_log : public logrec_t {
	void fill(const lpid_t* p, uint2_t tag, int l) {
	  _cat = 0|t_redo|t_logical, _type = t_create_ext_list;
	  logrec_t::fill(p, tag, l);
	}
      public:
	create_ext_list_log (const page_p& page, const stid_t& stid, extnum_t prev, extnum_t next, extnum_t count, const extnum_t* list);
	create_ext_list_log (logrec_t*)   {};
	
	void redo(page_p*);
	
    };

    class free_ext_list_log : public logrec_t {
	void fill(const lpid_t* p, uint2_t tag, int l) {
	  _cat = 0|t_redo|t_logical, _type = t_free_ext_list;
	  logrec_t::fill(p, tag, l);
	}
      public:
	free_ext_list_log (const page_p& page, const stid_t& stid, extnum_t head, extnum_t count);
	free_ext_list_log (logrec_t*)   {};
	
	void redo(page_p*);
	
    };

    class set_ext_next_log : public logrec_t {
	void fill(const lpid_t* p, uint2_t tag, int l) {
	  _cat = 0|t_redo|t_logical, _type = t_set_ext_next;
	  logrec_t::fill(p, tag, l);
	}
      public:
	set_ext_next_log (const page_p& page, extnum_t ext, extnum_t new_next);
	set_ext_next_log (logrec_t*)   {};
	
	void redo(page_p*);
	
    };

    class store_operation_log : public logrec_t {
	void fill(const lpid_t* p, uint2_t tag, int l) {
	  _cat = 0|t_redo|t_undo|t_logical, _type = t_store_operation;
	  logrec_t::fill(p, tag, l);
	}
      public:
	store_operation_log (const page_p& page, const store_operation_param& op);
	store_operation_log (logrec_t*)   {};
	
	void redo(page_p*);
	void undo(page_p*);
    };

    class page_link_log : public logrec_t {
	void fill(const lpid_t* p, uint2_t tag, int l) {
	  _cat = 0|t_redo|t_undo, _type = t_page_link;
	  logrec_t::fill(p, tag, l);
	}
      public:
	page_link_log (const page_p& page, shpid_t new_prev, shpid_t new_next);
	page_link_log (logrec_t*)   {};
	
	void redo(page_p*);
	void undo(page_p*);
    };

    class page_insert_log : public logrec_t {
	void fill(const lpid_t* p, uint2_t tag, int l) {
	  _cat = 0|t_redo|t_undo, _type = t_page_insert;
	  logrec_t::fill(p, tag, l);
	}
      public:
	page_insert_log (const page_p& page, int idx, int cnt, const cvec_t* vec);
	page_insert_log (logrec_t*)   {};
	
	void redo(page_p*);
	void undo(page_p*);
    };

    class page_remove_log : public logrec_t {
	void fill(const lpid_t* p, uint2_t tag, int l) {
	  _cat = 0|t_redo|t_undo, _type = t_page_remove;
	  logrec_t::fill(p, tag, l);
	}
      public:
	page_remove_log (const page_p& page, int idx, int cnt);
	page_remove_log (logrec_t*)   {};
	
	void redo(page_p*);
	void undo(page_p*);
    };

    class page_format_log : public logrec_t {
	void fill(const lpid_t* p, uint2_t tag, int l) {
	  _cat = 0|t_redo|t_undo, _type = t_page_format;
	  logrec_t::fill(p, tag, l);
	}
      public:
	page_format_log (const page_p& page, int idx, int cnt, const cvec_t* vec);
	page_format_log (logrec_t*)   {};
	
	void redo(page_p*);
	void undo(page_p*);
    };

    class page_mark_log : public logrec_t {
	void fill(const lpid_t* p, uint2_t tag, int l) {
	  _cat = 0|t_redo|t_undo, _type = t_page_mark;
	  logrec_t::fill(p, tag, l);
	}
      public:
	page_mark_log (const page_p& page, int idx);
	page_mark_log (logrec_t*)   {};
	
	void redo(page_p*);
	void undo(page_p*);
    };

    class page_reclaim_log : public logrec_t {
	void fill(const lpid_t* p, uint2_t tag, int l) {
	  _cat = 0|t_redo|t_undo, _type = t_page_reclaim;
	  logrec_t::fill(p, tag, l);
	}
      public:
	page_reclaim_log (const page_p& page, int idx, const cvec_t& vec);
	page_reclaim_log (logrec_t*)   {};
	
	void redo(page_p*);
	void undo(page_p*);
    };

    class page_shift_log : public logrec_t {
	void fill(const lpid_t* p, uint2_t tag, int l) {
	  _cat = 0|t_redo|t_undo, _type = t_page_shift;
	  logrec_t::fill(p, tag, l);
	}
      public:
	page_shift_log (const page_p& page, int idx2, page_s::slot_length_t off2, page_s::slot_length_t len2, int idx1, page_s::slot_length_t off1);
	page_shift_log (logrec_t*)   {};
	
	void redo(page_p*);
	void undo(page_p*);
    };

    class page_splice_log : public logrec_t {
	void fill(const lpid_t* p, uint2_t tag, int l) {
	  _cat = 0|t_redo|t_undo, _type = t_page_splice;
	  logrec_t::fill(p, tag, l);
	}
      public:
	page_splice_log (const page_p& page, int idx, int start, int len, const cvec_t& vec);
	page_splice_log (logrec_t*)   {};
	
	void redo(page_p*);
	void undo(page_p*);
    };

    class page_splicez_log : public logrec_t {
	void fill(const lpid_t* p, uint2_t tag, int l) {
	  _cat = 0|t_redo|t_undo, _type = t_page_splicez;
	  logrec_t::fill(p, tag, l);
	}
      public:
	page_splicez_log (const page_p& page, int idx, int start, int len, int osave, int nsave, const cvec_t& vec);
	page_splicez_log (logrec_t*)   {};
	
	void redo(page_p*);
	void undo(page_p*);
    };

    class page_set_byte_log : public logrec_t {
	void fill(const lpid_t* p, uint2_t tag, int l) {
	  _cat = 0|t_redo|t_undo, _type = t_page_set_byte;
	  logrec_t::fill(p, tag, l);
	}
      public:
	page_set_byte_log (const page_p& page, int idx, u_char old, u_char bits, int op);
	page_set_byte_log (logrec_t*)   {};
	
	void redo(page_p*);
	void undo(page_p*);
    };

    class page_image_log : public logrec_t {
	void fill(const lpid_t* p, uint2_t tag, int l) {
	  _cat = 0|t_redo, _type = t_page_image;
	  logrec_t::fill(p, tag, l);
	}
      public:
	page_image_log (const page_p& page);
	page_image_log (logrec_t*)   {};
	
	void redo(page_p*);
	
    };

    class btree_purge_log : public logrec_t {
	void fill(const lpid_t* p, uint2_t tag, int l) {
	  _cat = 0|t_redo|t_undo|t_logical, _type = t_btree_purge;
	  logrec_t::fill(p, tag, l);
	}
      public:
	btree_purge_log (const page_p& page);
	btree_purge_log (logrec_t*)   {};
	
	void redo(page_p*);
	void undo(page_p*);
    };

    class btree_insert_log : public logrec_t {
	void fill(const lpid_t* p, uint2_t tag, int l) {
	  _cat = 0|t_redo|t_undo|t_logical, _type = t_btree_insert;
	  logrec_t::fill(p, tag, l);
	}
      public:
	btree_insert_log (const page_p& page, int idx, const cvec_t& key, const cvec_t& el, bool unique);
	btree_insert_log (logrec_t*)   {};
	
	void redo(page_p*);
	void undo(page_p*);
    };

    class btree_remove_log : public logrec_t {
	void fill(const lpid_t* p, uint2_t tag, int l) {
	  _cat = 0|t_redo|t_undo|t_logical, _type = t_btree_remove;
	  logrec_t::fill(p, tag, l);
	}
      public:
	btree_remove_log (const page_p& page, int idx, const cvec_t& key, const cvec_t& el, bool unique);
	btree_remove_log (logrec_t*)   {};
	
	void redo(page_p*);
	void undo(page_p*);
    };

    class rtree_insert_log : public logrec_t {
	void fill(const lpid_t* p, uint2_t tag, int l) {
	  _cat = 0|t_redo|t_undo|t_logical, _type = t_rtree_insert;
	  logrec_t::fill(p, tag, l);
	}
      public:
	rtree_insert_log (const page_p& page, int idx, const nbox_t& key, const cvec_t& el);
	rtree_insert_log (logrec_t*)   {};
	
	void redo(page_p*);
	void undo(page_p*);
    };

    class rtree_remove_log : public logrec_t {
	void fill(const lpid_t* p, uint2_t tag, int l) {
	  _cat = 0|t_redo|t_undo|t_logical, _type = t_rtree_remove;
	  logrec_t::fill(p, tag, l);
	}
      public:
	rtree_remove_log (const page_p& page, int idx, const nbox_t& key, const cvec_t& el);
	rtree_remove_log (logrec_t*)   {};
	
	void redo(page_p*);
	void undo(page_p*);
    };

